Сделал два .csproj-а, Container и Container.Portable которые смотрят на один и ту же папку с файлами. Основной код заинклюжен в оба, вещи которые нужны или работают только в одном проекте (emit-ы, хаки для portable) заинклюжены только туда, куда нужно.
Получается огребалово, что при добавлении нового файла нужно инклюдить его в два проекта. Смотрел в качестве примеров на NInject и Newtonsoft.Json -- они делают так же. Только у них еще хуже, есть отдельные солюшны для каждой из платформ => больше открытых студий. Плохо.

Реалистичная альтернатива -- обойтись одним проектом, сделать разные билд конфиги и порешать все только за счет ifdef. Но тогда пришлось бы _большие_ куски кода прятать под #ifdef (сейчас получилось довольно локально), что наверное не прикольно. +В текущей схеме таким же образом как и основной  задублирован проект с тестами (Tests ссылается на Container, Tests.Portable на Container.Portable), и это дает возможность одним нажатием crtl+t+r прогнать тесты и на Portable версию и на обычную. Кажется, что это прикольно. С одним проектом это можно было бы решить... батником, котоый запускал бы одну конфигу, потом другую? Вроде не так круто.

Пикантные моменты, которые обнаружил походу
* У csproj-ей нельзя указывать путь до папки obj папки obj, поэтому если оставить у Tests и Tests.Portable одно и то же название сборки, то они начинают драться за папку. Дал  portable сборкам другое название.
* Если вынести csproj в соседнюю (на одном уровне с Container) папку (например, чтобы хаки для Portable лежали рядом), то VS файлы из-за того, что они лежат не под csproj-ем инклюдит как ссылки (<Link> в csproj), после чего в решарпере ломаются рефакторинги. Не надо так делать.

Что еще сделал и почему :
* ```Reflection.Emit``` и ```ConcurrentDictionary```.
 Скрыл под интерфейсами и локально написал ifdef-ы. Всего ifdef-ов получилось штуки три, вроде не так страшно.
```csharp
static CompiledMethods()
{
#if FULLFRAMEWORK
		var factory = new EmittedCompiledMethodFactory();
#else
		var factory = new ReflectionCompiledMethodFactory();
#endif
		compileMethodDelegate = factory.EmitCallOf;
}
```
* Новый reflection api - ```TypeInfo``` и Type. Просто юзаем его везде. Тут есть боль что писать x.GetTypeInfo().IsAbstract ломает мышечную память, но ничего другого не придумывается, и наверное, раз это новый api, то когда-нибудь он станет единственным.
* ```ICustomAttributeProvider```. В PCL его нет, но есть метод с его сигнатурой на Type и всех xxxInfo. Решил в AttributesCache принять object и утино откастать к каждой из известных реализаций. Раскопипастил экстеншны вродe IsDefined<T> для всех реализаций(Type, MethodInfo,...). Кажется, так лучше, чем делать эксеншны IsDefined<T> на object-е поскольку AttributesCache -- гораздо менее пользователский интерфейс, чем IsDefined<T>. Еще был вариант сделать свой ICustomAttributeProvider и структы которые бы оборачивали бы стандартные типы чтобы реализовать IMyCustomAttributeProvider и в его реализации позвать правильный метод на xxxInfo. Не захотелось инфецировать прикладной код этими хаками. Стопка экстеншнов скопипащена один раз, а про то что нужно писать new TypeWrap(type) пришлось бы помнмить.